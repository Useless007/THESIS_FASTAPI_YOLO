# app/routers/packing.py

from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutor
import asyncio
import requests
from fastapi import APIRouter, Depends, UploadFile, File, HTTPException,Query,Header, Response, Request, Form
from fastapi.responses import JSONResponse, StreamingResponse, FileResponse
from sqlalchemy import and_, or_
from sqlalchemy.orm import Session, joinedload
from app.models.user import User
from app.models.camera import Camera
from app.models.order import Order
from app.models.order_item import OrderItem
from app.models.product import Product
from app.schemas.order import VerifyRequest
from app.services.auth import get_user_with_role_and_position_and_isActive, get_current_user
from app.database import get_db
import subprocess,json,shutil,torch,os,cv2,traceback,threading,time
from ultralytics import YOLO

router = APIRouter(prefix="/packing", tags=["Packing Staff"])
stream_lock = asyncio.Lock()  # Lock ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á Stream

# ‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• YOLOv10
MODEL_PATH = "app/models/best.pt"
ONNX_MODEL_PATH = "app/models/best.onnx"
UPLOAD_DIR = "uploads/packing_images"
os.makedirs(UPLOAD_DIR, exist_ok=True)

# ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ ONNX model ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
if not os.path.exists(ONNX_MODEL_PATH):
    print(f"‚ö†Ô∏è ONNX model not found at {ONNX_MODEL_PATH}")
else:
    print(f"‚úÖ ONNX model found at {ONNX_MODEL_PATH}")

# stream_lock = threading.Lock()  # Lock ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á Stream

try:
    model = YOLO(MODEL_PATH)
except Exception as e:
    raise HTTPException(status_code=500, detail=f"‚ùå Failed to load YOLOv10 model: {str(e)}")

# ‚úÖ API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î ONNX model ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô frontend
@router.get("/model")
async def get_onnx_model(
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    """
    Return the ONNX model file for frontend real-time detection
    """
    if not os.path.exists(ONNX_MODEL_PATH):
        raise HTTPException(status_code=404, detail="ONNX model not found")
    
    # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ browser ‡πÅ‡∏õ‡∏•‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô media_type ‡πÄ‡∏õ‡πá‡∏ô application/octet-stream
    # ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ headers ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£ transform ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    return FileResponse(
        ONNX_MODEL_PATH, 
        media_type="application/octet-stream",
        filename="best.onnx",
        headers={
            "Content-Disposition": "attachment; filename=best.onnx",
            "Content-Type": "application/octet-stream",
            "Access-Control-Allow-Origin": "*",
            "Cache-Control": "no-cache, no-store, must-revalidate",
            "Pragma": "no-cache",
            "Expires": "0"
        }
    )

# ‚úÖ ‡∏Å‡∏•‡πâ‡∏≠‡∏á IP RTSP
RTSP_LINK = None

# gst_pipeline = (
#     f"rtspsrc location={RTSP_LINK} latency=0 ! "
#     "decodebin ! videoconvert ! appsink"
# )
# video_capture = cv2.VideoCapture(gst_pipeline, cv2.CAP_GSTREAMER)

video_capture = cv2.VideoCapture(RTSP_LINK, cv2.CAP_FFMPEG)
# video_capture = cv2.VideoCapture(RTSP_LINK)
video_capture.set(cv2.CAP_PROP_BUFFERSIZE, 1)  # ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î buffer ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏î‡πâ‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô
video_capture.set(cv2.CAP_PROP_FPS, 15)  # ‡∏•‡∏î Frame Rate
video_capture.set(cv2.CAP_PROP_POS_MSEC, 5000)  # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î timeout (5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)

video_captures = {}  # ‡πÉ‡∏ä‡πâ camera_id ‡πÄ‡∏õ‡πá‡∏ô key
detection_flags = {}  # ‡πÉ‡∏ä‡πâ camera_id ‡πÄ‡∏õ‡πá‡∏ô key ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
detection_processes = {}  # ‡πÄ‡∏Å‡πá‡∏ö process ‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö

async def start_camera(camera_id: int, rtsp_link: str):
    global video_captures

    # ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡∏õ‡∏¥‡∏î‡∏Å‡πà‡∏≠‡∏ô
    if camera_id in video_captures:
        video_captures[camera_id].release()
        del video_captures[camera_id]
        await asyncio.sleep(1)

    print(f"üîç ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id} ‡∏ó‡∏µ‡πà {rtsp_link}")
    
    video_capture = cv2.VideoCapture(rtsp_link, cv2.CAP_FFMPEG)
    if not video_capture.isOpened():
        print(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id}")
        return False

    video_captures[camera_id] = video_capture
    print(f"‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
    return True

async def stop_camera(camera_id: int):
    global video_captures, detection_flags
    if camera_id in video_captures:
        print(f"üõë ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id}")
        video_captures[camera_id].release()
        del video_captures[camera_id]
        # ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏î‡πâ‡∏ß‡∏¢
        if camera_id in detection_flags:
            detection_flags[camera_id] = False
        await asyncio.sleep(1)
    print(f"‚úÖ ‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id} ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î")

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏â‡∏•‡∏≤‡∏Å‡∏ö‡∏ô‡∏†‡∏≤‡∏û
def draw_detections(frame, detections):
    for detection in detections:
        label = detection["label"]
        conf = detection["confidence"]
        box = detection["box"]
        
        x1, y1, x2, y2 = [int(coord) for coord in box]
        
        # ‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏≠‡∏ö
        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
        
        # ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏â‡∏•‡∏≤‡∏Å
        y = y1 - 15 if y1 - 15 > 15 else y1 + 15
        
        # ‡∏ß‡∏≤‡∏î‡∏â‡∏•‡∏≤‡∏Å‡πÅ‡∏•‡∏∞‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏±‡πà‡∏ô
        label_text = f"{label}: {conf:.2f}"
        cv2.putText(frame, label_text, (x1, y), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
    
    return frame

# ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ö‡∏ô frame (‡∏ô‡∏≥‡∏°‡∏≤‡∏à‡∏≤‡∏Å yolo_worker.py ‡∏ã‡∏∂‡πà‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á)
def detect_frame(frame, device='cuda:0'):
    """
    ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÇ‡∏î‡∏¢‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏ü‡∏£‡∏°‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö yolo_worker.py
    """
    try:
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ frame ‡πÄ‡∏õ‡πá‡∏ô numpy array ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
        if frame is None or frame.size == 0:
            print("‚ùå Invalid frame for detection")
            return []
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á temp directory ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
        temp_dir = "uploads/temp_realtime"
        os.makedirs(temp_dir, exist_ok=True)
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô
        temp_path = os.path.join(temp_dir, f"temp_frame_{time.time()}.jpg")
        
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏û‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß
        cv2.imwrite(temp_path, frame)
        
        if not os.path.exists(temp_path):
            print(f"‚ùå Failed to write temporary file: {temp_path}")
            return []
            
        try:
            # ‡πÉ‡∏ä‡πâ subprocess ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å yolo_worker.py ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
            result = subprocess.run(
                ["python", "app/services/yolo_worker.py", temp_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            if result.returncode != 0:
                print(f"‚ùå YOLO worker error in real-time: {result.stderr}")
                return []
            
            # Parse JSON output
            try:
                start_index = result.stdout.find("{")
                end_index = result.stdout.rfind("}") + 1
                if start_index == -1 or end_index == 0:
                    return []
                clean_json = result.stdout[start_index:end_index]
                output = json.loads(clean_json)
                
                # ‡πÉ‡∏ä‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏à‡∏≤‡∏Å YOLO worker
                detections = output.get("detections", [])
                
                return detections
            except json.JSONDecodeError:
                print("‚ùå Failed to decode YOLO worker response in real-time.")
                return []
                
        finally:
            # ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏Å‡πá‡∏ï‡∏≤‡∏°
            try:
                if os.path.exists(temp_path):
                    os.remove(temp_path)
            except Exception as e:
                print(f"‚ö†Ô∏è Warning: Failed to delete temporary file: {e}")
    except Exception as e:
        print(f"‚ùå Error in frame detection: {str(e)}")
        traceback.print_exc()
        return []

# ‚úÖ ‡πÅ‡∏Ñ‡∏õ‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á
@router.get("/snapshot")
async def snapshot(
    camera_id: int = Query(..., description="ID ‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Ñ‡∏õ‡∏†‡∏≤‡∏û"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    global video_captures

    if camera_id not in video_captures or not video_captures[camera_id].isOpened():
        raise HTTPException(status_code=400, detail=f"Camera {camera_id} is not opened")

    success, frame = video_captures[camera_id].read()
    if not success:
        raise HTTPException(status_code=500, detail=f"Cannot read frame from camera {camera_id}")

    # encode ‡πÄ‡∏õ‡πá‡∏ô jpg
    _, buffer = cv2.imencode('.jpg', frame)

    return Response(content=buffer.tobytes(), media_type="image/jpeg")



# ‚úÖ ‡∏™‡∏ï‡∏£‡∏µ‡∏°‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á
@router.get("/stream")
async def stream_video(
    request: Request,
    camera_id: int = Query(..., description="ID ‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏ï‡∏£‡∏µ‡∏°"),
    token: str = Header(None),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    global video_captures

    # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏à‡∏≤‡∏Å DB
    camera = db.query(Camera).filter(Camera.id == camera_id).first()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")

    rtsp_link = camera.stream_url  # ‡∏î‡∏∂‡∏á RTSP link ‡∏à‡∏≤‡∏Å DB

    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
    if camera_id not in video_captures or not video_captures[camera_id].isOpened():
        await start_camera(camera_id, rtsp_link)

    # ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Stream
    async def generate():
        try:
            while True:
                if camera_id not in video_captures or not video_captures[camera_id].isOpened():
                    print(f"‚ö†Ô∏è ‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id} ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î")
                    break
                success, frame = video_captures[camera_id].read()
                if not success:
                    await asyncio.sleep(0.01)
                    continue
                _, buffer = cv2.imencode('.jpg', frame)
                yield (
                    b'--frame\r\n'
                    b'Content-Type: image/jpeg\r\n\r\n' + buffer.tobytes() + b'\r\n'
                )
                await asyncio.sleep(0.01)
        except Exception as e:
            print(f"‚ùå Error streaming camera {camera_id}: {e}")
        finally:
            await stop_camera(camera_id)

    return StreamingResponse(generate(), media_type="multipart/x-mixed-replace;boundary=frame")



# ‚úÖ ‡∏™‡∏ï‡∏£‡∏µ‡∏°‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÅ‡∏ö‡∏ö real-time
@router.get("/realtime-detect")
async def realtime_detect(
    request: Request,
    camera_id: int = Query(..., description="ID ‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏ï‡∏£‡∏µ‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö"),
    token: str = Header(None),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    global video_captures, detection_flags
    
    # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏à‡∏≤‡∏Å DB
    camera = db.query(Camera).filter(Camera.id == camera_id).first()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")

    rtsp_link = camera.stream_url  # ‡∏î‡∏∂‡∏á RTSP link ‡∏à‡∏≤‡∏Å DB

    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
    if camera_id not in video_captures or not video_captures[camera_id].isOpened():
        await start_camera(camera_id, rtsp_link)

    # ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° model ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö
    device = 'cuda:0' if torch.cuda.is_available() else 'cpu'
    print(f"üîç Running YOLO on device: {device} for camera {camera_id}")
    
    # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö
    detection_flags[camera_id] = True
    
    # ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Stream ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏
    async def generate():
        try:
            # ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏ü‡∏£‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß
            last_detection_time = 0
            detection_interval = 2.0  # ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ó‡∏∏‡∏Å 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (0.5 FPS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö)
            
            # ‡∏Å‡∏£‡∏≠‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (‡πÉ‡∏ä‡πâ‡∏ß‡∏≤‡∏î‡∏ö‡∏ô‡πÄ‡∏ü‡∏£‡∏°‡πÉ‡∏´‡∏°‡πà)
            last_detections = []
            
            # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ device ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö
            device = 'cuda:0' if torch.cuda.is_available() else 'cpu'
            print(f"üîç Running YOLO on device: {device} for camera {camera_id}")
            
            while detection_flags.get(camera_id, True):
                if camera_id not in video_captures or not video_captures[camera_id].isOpened():
                    print(f"‚ö†Ô∏è ‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id} ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î")
                    break
                    
                success, frame = video_captures[camera_id].read()
                if not success:
                    await asyncio.sleep(0.01)  # ‡∏•‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏≠‡πÄ‡∏õ‡πá‡∏ô 0.01 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                    continue
                
                current_time = time.time()
                should_detect = (current_time - last_detection_time) >= detection_interval
                
                # ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤
                if should_detect:
                    last_detection_time = current_time
                    
                    # ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡πâ‡∏ß‡∏¢ YOLO ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á (‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô subprocess)
                    try:
                        # ‡πÉ‡∏ä‡πâ ThreadPool ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ö‡∏•‡πá‡∏≠‡∏Ñ event loop
                        loop = asyncio.get_running_loop()
                        
                        # ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏ü‡∏£‡∏° (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå)
                        # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏ü‡∏£‡∏°‡πÄ‡∏õ‡πá‡∏ô numpy array ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö YOLO
                        detections = await loop.run_in_executor(
                            get_executor(),
                            detect_frame,
                            frame.copy(),  # ‡∏™‡πà‡∏á‡∏™‡∏≥‡πÄ‡∏ô‡∏≤‡∏Ç‡∏≠‡∏á‡πÄ‡∏ü‡∏£‡∏°‡πÑ‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
                            device
                        )
                        
                        # ‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏ß‡πâ
                        last_detections = detections
                        
                    except Exception as e:
                        print(f"‚ùå Error in real-time detection: {str(e)}")
                
                # ‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏≠‡∏ö‡∏•‡∏á‡∏ö‡∏ô‡πÄ‡∏ü‡∏£‡∏° (‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏° ‡πÉ‡∏ä‡πâ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î)
                if last_detections:
                    frame = draw_detections(frame, last_detections)
                
                # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô JPEG ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡πÑ‡∏õ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
                _, buffer = cv2.imencode('.jpg', frame)
                yield (
                    b'--frame\r\n'
                    b'Content-Type: image/jpeg\r\n\r\n' + buffer.tobytes() + b'\r\n'
                )
                
                # ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏´‡∏ô‡∏±‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡∏•‡∏î‡∏•‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏†‡∏≤‡∏û‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô)
                await asyncio.sleep(0.03)  # ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 30 FPS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏†‡∏≤‡∏û
                
        except Exception as e:
            print(f"‚ùå Error streaming camera with detection {camera_id}: {e}")
        finally:
            # ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á
            detection_flags[camera_id] = False

    return StreamingResponse(generate(), media_type="multipart/x-mixed-replace;boundary=frame")

# ‚úÖ ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÅ‡∏ö‡∏ö real-time
@router.get("/stop-realtime")
async def stop_realtime_detection(
    camera_id: int = Query(..., description="ID ‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    global detection_flags
    
    print(f"üîÑ ‡∏Ñ‡∏≥‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö real-time ‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id}")
    
    # ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á
    detection_flags[camera_id] = False
    
    return JSONResponse(content={"message": f"üõë ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö real-time ‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à"})

# ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á
@router.get("/stop-stream")
async def stop_stream(
    camera_id: int = Query(..., description="ID ‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    print(f"üîÑ ‡∏Ñ‡∏≥‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id}")
    
    await stop_camera(camera_id)

    return JSONResponse(content={"message": f"üõë ‡∏Å‡∏•‡πâ‡∏≠‡∏á {camera_id} ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à"})


# ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Executor
executor = ThreadPoolExecutor(max_workers=4) 

def get_executor():
    global executor
    if executor is None:
        executor = ThreadPoolExecutor(max_workers=4)
    return executor

# ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• YOLO
def process_yolo(file_path: str):
    """
    ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• YOLO ‡∏ö‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û
    """
    try:
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
        if not os.path.exists(file_path):
            print(f"‚ùå File not found: {file_path}")
            return []
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ CUDA (GPU) ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        device = 'cuda:0' if torch.cuda.is_available() else 'cpu'
        print(f"üîç Running YOLO on device: {device}")
        
        # ‡πÉ‡∏ä‡πâ file path ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á (‡∏≠‡∏¢‡πà‡∏≤‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô OpenCV image)
        results = model.predict(source=file_path, conf=0.1, iou=0.45, stream=False, device=device)
        detections = []

        for result in results:
            for box in result.boxes.data:
                x1, y1, x2, y2, conf, cls = box.tolist()
                if conf > 0.3:
                    label = model.names[int(cls)]
                    detections.append({
                        "label": label,
                        "confidence": float(conf),
                        "box": [float(x1), float(y1), float(x2), float(y2)],
                    })

        if torch.cuda.is_available():
            torch.cuda.empty_cache()

        print(f"‚úÖ YOLO processing completed: {len(detections)} objects detected.")
        return detections
    except Exception as e:
        print(f"‚ùå Error in YOLO processing: {str(e)}")
        traceback.print_exc()  # ‡πÄ‡∏û‡∏¥‡πà‡∏° traceback ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
        return []  # ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£ raise exception ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ



# ‚úÖ Route: ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏†‡∏≤‡∏û‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î
@router.post("/detect", response_class=JSONResponse)
async def detect_objects(
    file: UploadFile = File(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    """
    ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏à‡∏≤‡∏Å‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ subprocess ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å yolo_worker.py
    """  
    file_path = os.path.join(UPLOAD_DIR, file.filename)

    try:
        # ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        if not os.path.exists(file_path):
            raise HTTPException(status_code=400, detail="Uploaded image not found on server.")

        # ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô yolo_worker.py ‡∏ú‡πà‡∏≤‡∏ô subprocess
        result = subprocess.run(
            ["python", "app/services/yolo_worker.py", file_path],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        # Debug logs
        print("STDOUT:", result.stdout)
        print("STDERR:", result.stderr)

        if result.returncode != 0:
            print(f"‚ùå YOLO worker error: {result.stderr}")
            raise HTTPException(status_code=500, detail="YOLO worker failed.")

        # ‚úÖ ‡∏î‡∏∂‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ JSON ‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡∏à‡∏≤‡∏Å STDOUT
        try:
            start_index = result.stdout.find("{")
            end_index = result.stdout.rfind("}") + 1
            if start_index == -1 or end_index == 0:
                raise json.JSONDecodeError("No JSON found in stdout", result.stdout, 0)
            clean_json = result.stdout[start_index:end_index]
            output = json.loads(clean_json)
        except json.JSONDecodeError:
            print("‚ùå Failed to decode YOLO worker response.")
            raise HTTPException(status_code=500, detail="Invalid response from YOLO worker.")

        response = JSONResponse(content={"detections": output.get("detections", []), "image_path": file_path, "annotated_image_path": output.get("annotated_image", "") })

        # response = JSONResponse(content={"detections": [], "image_path": file_path}) # debug capture only comment out

        return response

    except Exception as e:
        print(f"‚ùå Unexpected error: {str(e)}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail="Unexpected server error during detection process.")


# Endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏•‡πâ‡∏≠‡∏á
@router.get("/cameras", response_class=JSONResponse)
def get_cameras(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    """
    ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ô DB
    ‡∏™‡∏°‡∏°‡∏∏‡∏ï‡∏¥‡∏ß‡πà‡∏≤ Model Camera ‡∏°‡∏µ attribute: id, table_number, name, stream_url
    """
    cameras = db.query(Camera).all()
    return [
        {
            "id": camera.id,
            # "table_number": camera.table_number,
            "name": camera.name,
            "stream_url": camera.stream_url
        } for camera in cameras
    ]

# Endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ packing
@router.get("/orders/packing", response_class=JSONResponse)
def get_packing_orders(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    """
    ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ packing ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏≥‡∏°‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏°‡∏µ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å assign ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å assign ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    """
    orders = db.query(Order)\
        .options(joinedload(Order.user))\
        .filter(or_(Order.assigned_to == None, Order.assigned_to == current_user.id))\
        .filter(Order.status.in_(["packing", "verifying"]))\
        .all()
    return [
        {
            "id": order.order_id,
            "email": order.user.email if order.user else None,  # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å order.email ‡πÄ‡∏õ‡πá‡∏ô order.user.email
            "total": order.total,
            "created_at": order.created_at,
            "items": order.order_items,
            "assigned_to": order.assigned_to
        } for order in orders
    ]

@router.put("/orders/{order_id}/assign", response_class=JSONResponse)
def assign_order(
    order_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    order = (
        db.query(Order)
        .options(
            joinedload(Order.user),
            joinedload(Order.order_items).joinedload(OrderItem.product)
        )
        .filter(
            and_(
                Order.order_id == order_id,
                Order.status.in_(["packing", "pending"]),
                Order.assigned_to == None
            )
        )
        .with_for_update()
        .first()
    )
    
    if not order:
        raise HTTPException(status_code=404, detail="Order not found or already assigned")

    order.assigned_to = current_user.id
    order.status = "verifying"
    db.commit()
    db.refresh(order)

    # Format the order items properly
    formatted_items = [
        {
            "product_id": item.product_id,
            "product_name": item.product.name if item.product else "Unknown",
            "quantity": item.quantity,
            "price": item.price_at_order,
            "total": item.total_item_price
        }
        for item in order.order_items
    ]

    order_data = {
        "order_id": order.order_id,
        "customer_email": order.user.email if order.user else None,
        "total_price": order.total,
        "items": formatted_items,
        "created_at": order.created_at.strftime("%Y-%m-%d %H:%M:%S"),
    }

    return JSONResponse(content=order_data)

@router.post("/orders/{order_id}/upload-image", response_class=JSONResponse)
async def upload_packed_image(
    order_id: int,
    file: UploadFile = File(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    """
    ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏û‡πá‡∏Ñ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß ‡πÅ‡∏•‡∏∞‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    """
    order = db.query(Order).filter(Order.order_id == order_id, Order.assigned_to == current_user.id).first()
    if not order:
        raise HTTPException(status_code=404, detail="Order not found or not assigned to you")

    upload_dir = "uploads/packed_orders"
    os.makedirs(upload_dir, exist_ok=True)
    file_path = os.path.join(upload_dir, f"{order_id}.jpg")

    # ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)

    order.image_path = file_path  # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å path ‡πÑ‡∏ü‡∏•‡πå‡∏•‡∏á database
    db.commit()

    return JSONResponse(content={"message": "Image uploaded successfully", "image_path": file_path})

@router.put("/orders/{order_id}/verify", response_class=JSONResponse)
async def verify_order(
    order_id: int,
    verified: bool = Form(...),
    file: UploadFile = File(None),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    """
    ‚úÖ ‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏Å‡∏î‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Ñ‡∏£‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö
    """
    order = db.query(Order).filter(Order.order_id == order_id, Order.assigned_to == current_user.id).first()
    if not order:
        raise HTTPException(status_code=404, detail="Order not found or not assigned to you")

    if not file and not order.image_path:
        raise HTTPException(status_code=400, detail="‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Å‡πà‡∏≠‡∏ô")

    if file:
        upload_dir = "uploads/packed_orders"
        os.makedirs(upload_dir, exist_ok=True)
        file_path = os.path.join(upload_dir, f"{order_id}.jpg").replace("\\", "/")
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        order.image_path = file_path

    # ‚úÖ ‡∏ñ‡πâ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö ‚Üí ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô "pending" ‡πÅ‡∏•‡∏∞‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÅ‡∏≠‡∏î‡∏°‡∏¥‡∏ô
    if not verified:
        order.status = "pending"
        db.commit()

        # ‚úÖ ‡∏™‡πà‡∏á HTTP Request ‡πÑ‡∏õ‡∏¢‡∏±‡∏á Home ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô Admin
        try:
            url = "http://localhost:8000/admin/trigger-notify"
            # url = "https://home.jintaphas.tech/admin/trigger-notify"
            payload = {
                "order_id": order_id,
                "reason": "‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö"
            }
            resp = requests.post(url, json=payload, timeout=5)
            print("Notify admin response:", resp.status_code, resp.text)
        except Exception as e:
            print("Error calling home to notify admin:", e)

        return JSONResponse(content={"message": "Order marked as pending", "order_id": order_id, "status": "pending"})

    # ‚úÖ ‡∏ñ‡πâ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Ñ‡∏£‡∏ö ‚Üí ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏õ‡πá‡∏ô "completed"
    order.is_verified = verified
    order.status = "completed"
    db.commit()

    return JSONResponse(content={"message": "Order verification updated", "order_id": order_id, "status": "completed"})

@router.get("/orders/current", response_class=JSONResponse)
def get_current_order(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    """
    ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏û‡πá‡∏Ñ‡∏≠‡∏¢‡∏π‡πà
    """
    order = db.query(Order)\
        .options(
            joinedload(Order.user),
            joinedload(Order.order_items).joinedload(OrderItem.product)
        )\
        .filter(
            Order.assigned_to == current_user.id,  
            Order.status.in_(["verifying", "packing"])
        )\
        .order_by(Order.created_at.desc())\
        .first()

    if not order:
        return JSONResponse(content={"message": "No active order"}, status_code=200)

    formatted_items = [
        {
            "product_id": item.product_id,
            "product_name": item.product.name if item.product else "Unknown",
            "quantity": item.quantity,
            "price": item.price_at_order,
            "total": item.total_item_price
        }
        for item in order.order_items
    ]

    return JSONResponse(content={
        "order_id": order.order_id,
        "customer_email": order.user.email if order.user else None,
        "total_price": order.total,
        "items": formatted_items,
        "created_at": order.created_at.strftime("%Y-%m-%d %H:%M:%S"),
        "image_path": order.image_path
    })

@router.get("/orders/{order_id}/image", response_class=FileResponse)
async def get_order_image(
    order_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    ‚úÖ ‡πÉ‡∏´‡πâ API ‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÅ‡∏û‡πá‡∏Ñ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
    """
    order = db.query(Order).filter(Order.order_id == order_id, Order.user_id == current_user.id).first()
    
    if not order:
        raise HTTPException(status_code=404, detail="Order not found or you don't have permission.")

    # ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á‡πÑ‡∏´‡∏°
    if not order.image_path or not os.path.exists(order.image_path):
        raise HTTPException(status_code=404, detail="No packed order image found.")

    return FileResponse(order.image_path, media_type="image/jpeg")

# Add a new endpoint to fetch all product names for the YOLO detector
@router.get("/product-names", response_class=JSONResponse)
def get_product_names(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_user_with_role_and_position_and_isActive(1, 4))
):
    """
    ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö YOLO detector
    """
    products = db.query(Product.name).all()
    product_names = [product[0] for product in products]
    
    return JSONResponse(content={"product_names": product_names})